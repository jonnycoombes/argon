# Argon Content Service Layer
# Version 1.0.2.1

## Overview

The Argon Content Service Layer provides a storage-independent facade layer designed to be deployed in front of either native filesystem
storage, or alternatively in front of one or several OpenText Content Server 16 instances.

The service layer abstracts the underlying storage to a number of *collections* which are then *bound* to an underlying storage provider.
Within each collection, it is possible to store *versionable items* which generally equate to a stored document.

The Content Service Layer is dependent on it's own independent datastore (the default implementation is an underlying SQL database) wherein
it stores meta-data and information relating to the collections and their associated items. This meta-data *may* or *may not* correspond to
meta-data residing within the underlying storage layer.

The Content Service Layer (CSL) presents a RESTful interface to consuming client applications, and presents a Swagger UI detailing the
various available operations as an OpenAPI v3.0 specification.

Some general concepts relating to the core abstractions within the Content Service Layer:

- Every object within the content service layer (collection, item, version) is uniquely identified by a UUID generated by the CSL.
- The UUID associated with a given object is typically used as the resource identifier within RESTful calls to the CSL.
- Items stored within a given collection hosted by the CSL have a generic property bag associated with them, allowing for schema-free
  storage of information against the item.
- Collections may have *constraints* associated with them, in order to enforce the existence of mandatory properties, the types of
  properties etc...
- Items within a given collection may have multiple *versions* which may or may not be translated into discrete version entities within the
  underlying storage layer, depending on whether the storage layer supports versioning.  (In the case of OTCS16, versions are equated and
  map to versions of a parent document within the underlying repository).

Some general implementation notes about the Content Service Layer:

- The CSL is implemented using .NET Core 3.1, although has been built and tested against .NET 5.
- The Glencore published version of the CSL contains integration touchpoints within the Glencore Tactical Authentication
  service/micro-service.
- C# 8.0 is the current implementation dialect for the CSL.
- The CSL has a dependency on a legacy version of the JCS Neon Glow library (version 0.2.10 at the time of writing) for a minimal subset of
  functionality, mainly logging utilities.
- The baked-in unit tests have dependencies on an external OTCS 16 instance for full coverage of all test cases. Test cases may be filtered
  based on attributed categories/tags within the unit test source code.

## Configuration and Deployment

Deployment of the CSL is relatively straightforward and consists of the following steps.  (These steps assume that the CSL is stored within
a known remote Git repository):

1. Pull/clone the latest available version of the CSL source from the nominated repository
   e.g.: `git clone git@bitbucket.org:jcs-software/argon.git`
2. Decide which build configuration to run on the deloyment host (Release or Debug).
3. Make necessary changes to the `appsettings.json` and `appsettings.<Environment>.json` file.
4. Run the application through the standard `dotnet run` command.

Launch profiles are provided for both self-hosted (Kestrel) or IIS-dependent deployments. Additional launch profiles may be created/added
using the standard .NET Core `launch.json` file.

### Standard Configuration Options
The CSL utilises the standard .NET core application settings mechanism for configuration.  Default values may be configured within the
`appsettings.json` file, and then overridden on a per-environment basis using a separate `appsettings.<ENVIRONMENT>.json` file.

#### `appsettings.json` General Structure

The general structure of the CSL configuration file follows .NET Core standards.  In order to allow for the configuration of the various dependent components, it is split into three main sections:

| Section Root Key | Description                   |
|------------------|-------------------------------|
|Serilog           | Serilog configuration settings|
|ConnectionStrings | Standard .NET connection string settings.  By default, "DefaultConnection" is used |
|Argon             | Section containing the various bindings for the Argon virtual storage providers (see below)|
|RoleBasedPermissions| Section specific to Glencore role-based authentication settings|

#### Glencore-Specific Octopus Placeholders

Given that Argon is deployed via Octopus within Glencore, the default `appsettings.json` file contains a number of placeholders which are statically re-written during deployment.
The placeholders of note are given in the table below:

|Placeholder | Description|
|------------|------------|
|CONTENTSERVERSERVICELAYER_CONNECTIONSTRING | Replaced by the current environmental connection string|
| CONTENTSERVERSERVICELAYER_BINDING_FS|Contains the name/tag for a given Native FS provider|
|CONTENTSERVERSERVICELAYER_BINDING_FS_ROOTPATH|For native FS providers, this will contain the root path for the storage of collections|
|CONTENTSERVERSERVICELAYER_BINDING_OTCS_ENDPOINT|For OTCS providers, this must contain the endpoint (address) of the root CWS (Content Web Services) application on the target system|

*Note that because the Octopus binding mechanism is static rather than dynamic, the exact number and designation of replacement tags may change, based on the number of configured providers. 

**Octopus placeholders are all surrounded by braces `{}` and prefixed with a '$' character. 


The Content Service Layer configuration may contain an arbitrary list of specific storage/collection bindings which can be of two main types:

1. OTCS Storage Binding (collections are stored relative to a OTCS root location)
2. Native FS Storage Binding (collections are stored on filesystem relative to a provider FS path).

Depending on the type of binding being specified, there are different options which may be included within each binding configuration.  
The array of binding configurations should be given as children of the `argon.virtualStorageOptions.bindings` section of the configuration file.

#### OTCS Storage Provider

The available OTCS storage provider configuration options are summarised below:

| Configuration Key | Description | Example                   |
|:------------------|:------------|:--------------------------|
|`tag` |The user-defined identifier for the storage binding | `"tag" : "Test OTCS Provider"`|
|`providerType`|The type of the provider, must be `openTextSoap`|`"providerType" : "openTextSoap"`|
|`description`|An optional description for the binding|`"description" : "This is a sample binding"`|
|`properties.endpoint`|The CWS endpoint for the binding|`"endpoint":"https://otcs.host/cws"`|
|`properties.rootCollectionPath`|The path to the collection root storage folder within OTCS.  This path is taken to be relative to the Enterprise Workspace|`"rootCollectionPath":"/Argon/Collections"`|
|`properties.authType`|The authentication type to use|Two authentication types are supported.  `integrated` or `basic`. (See below).|
|`properties.user`|The user to be authenticated against OTCS if the `authType` is set to `basic`|Note that this username will reside within the configuration file unencrypted.|
|`properties.password`|The password to be used during authentication against OTCS if the `authType` is set to `basic`|Note that this password will reside within the configuration file unencrypted.|

The Content Service Layer currently supports two modes of authentication into any underlying OTCS instance:

1. `integrated` This method will utilise a **HTTPS** connection through to CWS (Content Server Web Services) and utilise Integrated Windows Authentication in order to negotiate a valid OTCS token for subsequent use in outcalls to the OTCS SOAP layer.  
When `integrated` authentication is configured, the `user` and `password` configuration settings for a binding are *not* required.
2. `basic` This method will utilise a **HTTP** (plaintext) connection through to the underlying CWS layer, and will present username and password credentials to the CWS authentication endpoint 
using the values provided within the `user` and `password` configuration settings.  *Empty or null passwords are not supported*.

#### Native Filesystem Storage Provider

The available native filesystem storage provider configuration options are summarised below:

| Configuration Key | Description | Example                   |
|:------------------|:------------|:--------------------------|
|`tag`|The user-defined identifier for the storage binding|`"tag": "Test Native FS Provider"`|
|`providerType`|The type of the provider. Must be `nativeFileSystem`||
|`description`|An optional description for the binding|`"description" : "This is a test native filesystem provider"`|
|`properties.rootPath`|The root path for the storage of collections and their items/versions|`"properties.rootPath" : "/var/opt/argon"`|

## Archiving Support

In addition to the support of "native" Argon collections, from version 1.0.2.1 and above Argon also provides support for
the configuration of *archive* collections which are bound to underlying instances of OpenText Content Server 16.  The
configuration for such archives shares similarities with the configuration of the OTCS Storage Provider in that each 
archive binding requires a set of parameters defining the location and credentials for a valid CWS (Content Web Services)
endpoint.

Each archive collection may be configured by adding an entry to the *argon:archiveStorageOptions:bindings* array.  Each 
entry within this array may have the following configuration parameters:

| Configuration Key | Description | Example                     |
|:------------------|:------------|:----------------------------|
|`tag`|The user-defined tag used to identify the archive|`"tag": "testOTCSArchive"`|
|`endpoint`|The base endpoint address for CWS web services|`"endpoint": "https://<otcs.somehost>/cws"`|
|`user`|The name of the authentication user to be used by the underlying service client|`"user": "MrFluffy"`|
|`password`|The password for be used within authentication calls by the underlying service client|`"password": "VerySecret"`|

As with the OTCS VSP provider, if no user and password are supplied within binding definition, then Argon will assume that 
integrated authentication is to be used, and the service identity associated with the running Argon process will be used 
during initial authentication outcalls to the CWS layer.

It is possible to utilise user *impersonation* within archiving endpoints, whereby initial authentication into OTCS is
performed using the configured credentials (either Basic or Integrated) but then a given impersonation user identity is
then extracted from the claims within an inbound JWT bearer token. By default, the claim "otcsimp" claim is looked for 
within the inbound token.

### Archiving Paths
Retrieval of content from within a given configured OTCS archive is performed through the */archive* endpoint defined 
within the Swagger API definition for the Argon service.  Rather than the client having to know the *node ID* of a 
specific item during retrieval operations, the archive endpoint utilises *paths* to individual items *relative to the CS
Enterprise* root volume node.

For example, in order to retrieve the contents of a document named *test.docx* located within a folder underneath the
Enterprise within a sub-folder called *Test Archive*, the format of the endpoint request would be as follows:

> https://<argon.host>/api/v1/archive/{tag}/Test%20Archive/test.docx?meta=false

The operations associated with the archive endpoint are much simpler than those associated with *native* Argon 
collections and are summarised within the following table:

|Operation|HTTP Verb|Description|meta|archive|Example|
|:--------|:--------|:----------|:---|:------|:------|
|Download file|GET|Download a single file|`false`|`null`|`https://argon/api/v1/archive/{tag}/{Sub-Folder}/{File}`
|Download file meta|GET|Download meta for a single file|`true`|`null`|`https://argon/api/v1/archive/{tag}/{Sub-Folder}/{File}?meta=true`
|Download folder archive (Zip)|GET|Download folder contents as a zip archive|`false`|`zip`|`https://argon/api/v1/archive/{tag}/{Sub-Folder}?meta=false&archive=zip`
|Download folder archive (Pdf)|GET|Download folder contents as a single PDF|`false`|`pdf`|`https://argon/api/v1/archive/{tag}/{Sub-Folder}?meta=false&archive=pdf`

These four operations should form the basis of any integration testing scripts performed upon a deployed instance of
Argon.

## Building

Build of the Content Service Layer is standard and can be performed (subject to satisfying all necessary dependencies)
with the standard
`dotnet build` command. The basic steps are:

1. Clone the Argon repository to you build environment in a suitable location.
2. Execute `dotnet build` for a default, *Debug* build.

Build has been testsed against .NET Core 3.x in the following environments:

1. `Windows 10`
2. `Mac OSX Catalina`
3. `Mac OSX Big Sur`
4. `Ubuntu 16.04 LTS`
5. `Ubuntu 18.04 LTS`
6. `Kali Linux 2020.4`

#### Running Unit Tests

Content Service Layer unit tests may be executed using the standard `dotnet test` command, however several of the unit tests also perform limited 
integration tests against a nominated development/build OTCS instance.  A seperate configuration file for test purposes is provided and is named
`appsettings.Test.json`.  In order to disable integration tests within the test suite, utilise the built-in test filtering capability of 
`dotnet test` by passing through a suitable filter.  The available test categories are as follows:

|Tag|Description|
|--------|-----------|
|`Category=Unit`|All unit tests belong to this category.|
|`Provider=XXXX`|Unit tests against a specific provider.  The valid values are `OTCS` for OTCS tests, `VSP` for default native filesystem tests.|

For example, in order to *not run* any OTCS-related unit tests (i.e. those dependent on an external OTCS instance) the following test command may be used: `dotnet test --filter="Provider=VSP"`.




