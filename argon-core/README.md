# Argon Content Service Layer

## Overview

The Argon Content Service Layer provides a storage-independent facade layer designed to be deployed in front of either native filesystem
storage, or alternatively in front of one or several OpenText Content Server 16 instances.

The service layer abstracts the underlying storage to a number of *collections* which are then *bound* to an underlying storage provider.
Within each collection, it is possible to store *versionable items* which generally equate to a stored document.

The Content Service Layer is dependent on it's own independent datastore (the default implementation is an underlying SQL database) wherein
it stores meta-data and information relating to the collections and their associated items. This meta-data *may* or *may not* correspond to
meta-data residing within the underlying storage layer.

The Content Service Layer (CSL) presents a RESTful interface to consuming client applications, and presents a Swagger UI detailing the
various available operations as an OpenAPI v3.0 specification.

Some general concepts relating to the core abstractions within the Content Service Layer:

- Every object within the content service layer (collection, item, version) is uniquely identified by a UUID generated by the CSL.
- The UUID associated with a given object is typically used as the resource identifier within RESTful calls to the CSL.
- Items stored within a given collection hosted by the CSL have a generic property bag associated with them, allowing for schema-free
  storage of information against the item.
- Collections may have *constraints* associated with them, in order to enforce the existence of mandatory properties, the types of
  properties etc...
- Items within a given collection may have multiple *versions* which may or may not be translated into discrete version entities within the
  underlying storage layer, depending on whether the storage layer supports versioning.  (In the case of OTCS16, versions are equated and
  map to versions of a parent document within the underlying repository).

Some general implementation notes about the Content Service Layer:

- The CSL is implemented using .NET Core 3.1, although has been built and tested against .NET 5.
- The Glencore published version of the CSL contains integration touchpoints within the Glencore Tactical Authentication
  service/micro-service.
- C# 8.0 is the current implementation dialect for the CSL.
- The CSL has a dependency on a legacy version of the JCS Neon Glow library (version 0.2.10 at the time of writing) for a minimal subset of
  functionality, mainly logging utilities.
- The baked-in unit tests have dependencies on an external OTCS 16 instance for full coverage of all test cases. Test cases may be filtered
  based on attributed categories/tags within the unit test source code.

## Configuration and Deployment

Deployment of the CSL is relatively straightforward and consists of the following steps.  (These steps assume that the CSL is stored within
a known remote Git repository):

1. Pull/clone the latest available version of the CSL source from the nominated repository
   e.g.: `git clone git@bitbucket.org:jcs-software/argon.git`
2. Decide which build configuration to run on the deloyment host (Release or Debug).
3. Make necessary changes to the `appsettings.json` and `appsettings.<Environment>.json` file.
4. Run the application through the standard `dotnet run` command.

Launch profiles are provided for both self-hosted (Kestrel) or IIS-dependent deployments. Additional launch profiles may be created/added
using the standard .NET Core `launch.json` file.

### Standard Configuration Options

#### OTCS Storage Provider

#### Native Filesystem Storage Provider

## Building

#### Default Development Build

#### Running Unit Tests




